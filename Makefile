#!/usr/bin/make -f

# fMakefile - Ready to use Makefile for simple Fortran projects
# with automatic targets and prerequisites (module dependencies)
#
# Copyright (c) 2019 André Chalella
# MIT License - see file LICENSE for full text
#
# fMakefile needs no modification to work with any simple Fortran project,
# "simple" being defined by the rules below:
#
#     1) Module source files must contain one complete module, and nothing else.
#     2) Module names must be the same as their source file names.
#     3) All module files must be in one directory.
#     4) Program source files must contain only one complete program, too.
#     5) All program files must be in one directory.
#        Note: there's one directory for test program files.
#     6) You're ok with programs being statically linked to their every
#        dependency object file (defined by USE statements). Some of them aren't
#        strictly needed sometimes (e.g. modules that contain only types). Very
#        small overhead, though, and makes prerequisite generation much simpler.
#     7) You're ok with the default directory structure. It's easily
#        customizable, though. Default (summarized) is below.
#
#            PROJECT ROOT      MAKEFILE VAR          WHAT GOES HERE
#            ├── src           $(SRCDIR)             Program sources
#            │   ├── mod       $(MODDIR_SUFFIX)      Module sources
#            │   └── test      $(TESTDIR_SUFFIX)     Program sources (tests)
#            ├── build (tree)  $(BUILDDIR_PREFIX)    Binaries and .mod files
#            └── dep   (tree)  $(DEPDIR)             Dependency Makefiles (.d)
#
#        - More details on the directory structure in README.md.
#        - More details on the (autogenerated) .d files in README.md.
#
# Features:
#
#     - Dependency lookup through static source scan (awk script). Programs
#       aren't linked to every single module available, only to "USE"d ones.
#     - Automatic targets for fully building each individual source file.
#       Examples: 'make main_prog', 'make mod_calculate', 'make test_fourier_8'
#     - Targets for making: exes (obviously), tests, mods and deps.
#     - Colorized output for each build step.
#     - Two build configurations (compiler/linker flags): DEBUG and RELEASE.
#
# Feel free to customize this file. Most variables you'll want to change have
# UPPERCASE names. If you need to change the other ones, to make bigger changes,
# make sure to search how they're used first.
#
# Paths with spaces are not supported. It's by design. However, feel free to
# quote all path variables if you need to support paths with spaces.
#
# Run "make stripmakefile" when you grow sick of these comments.

#####################
### CONFIGURATION ###
#####################

SHELL := /bin/sh
MAKEFLAGS += --no-builtin-rules

FC := gfortran
FEXT := f90

# ENV: BUILD=debug|release
BUILD ?= debug

AWK := awk

MKDIR := mkdir -p
RMDIR := rm -rf

# Colors for distinguishing the build steps from the myriad of build commands.
# Google "shell colors" for complete reference of color codes.
# Default is: Light Blue, Light Green, Light Purple (looks great in my setup).

COLOR_COMPILE := \e[1;49;34m
COLOR_LINK := \e[1;49;32m
COLOR_DONE := \e[1;49;35m
COLOR_NONE := \e[0m

MSG_DONE = 'Finished making $<'

# DIRECTORY STRUCTURE
#
# .                       NAME VARIABLE       FULL PATH VARIABLE  AUTOGENERATED?
# ├── build               $(BUILDDIR_PREFIX)  $(BUILDDIR_PREFIX)       yes
# │   └── debug           $(BUILD) [env]      $(builddir)              yes
# │       ├── bin         $(BINDIR_SUFFIX)    $(bindir)                yes
# │       │   └── test       see src tree     $(bintestdir)            yes
# │       ├── mod            see src tree     $(moddir)                yes
# │       └── obj         $(OBJDIR_SUFFIX)    $(objdir)                yes
# │           ├── mod        see src tree     $(objmoddir)             yes
# │           └── test       see src tree        none                  yes
# ├── dep                 $(DEPDIR)           $(DEPDIR)                yes
# │   ├── bin                see build tree   $(depbindir)             yes
# │   │   └── test           see src tree        none                  yes
# │   └── obj                see build tree   $(depobjdir)             yes
# │       ├── mod            see src tree        none                  yes
# │       └── test           see src tree        none                  yes
# └── src                 $(SRCDIR)           $(srcexedir)        *    NO    *
#     ├── mod             $(MODDIR_SUFFIX)    $(srcmoddir)        *    NO    *
#     └── test            $(TESTDIR_SUFFIX)   $(srctestdir)       *    NO    *
#
#  More details in README.md.

SRCDIR := src
DEPDIR := dep
BUILDDIR_PREFIX := build
BINDIR_SUFFIX := bin
OBJDIR_SUFFIX := obj
MODDIR_SUFFIX := mod
TESTDIR_SUFFIX := test

srcexedir := $(SRCDIR)
srcmoddir := $(SRCDIR)/$(MODDIR_SUFFIX)
srctestdir := $(SRCDIR)/$(TESTDIR_SUFFIX)

depbindir := $(DEPDIR)/$(BINDIR_SUFFIX)
depobjdir := $(DEPDIR)/$(OBJDIR_SUFFIX)

builddir := $(BUILDDIR_PREFIX)/$(BUILD)
bindir := $(builddir)/$(BINDIR_SUFFIX)
bintestdir := $(bindir)/$(TESTDIR_SUFFIX)
objdir := $(builddir)/$(OBJDIR_SUFFIX)
objmoddir := $(objdir)/$(MODDIR_SUFFIX)
moddir := $(builddir)/$(MODDIR_SUFFIX)

# All source files, with directories and extensions.

src_exes := $(wildcard $(srcexedir)/*.$(FEXT))
src_mods := $(wildcard $(srcmoddir)/*.$(FEXT))
src_tests := $(wildcard $(srctestdir)/*.$(FEXT))

# All source files, without directories or extensions.
#
# I dubbed these "basenames", even though, in make, basename() doesn't strip
# directories from the path, only suffixes (extensions). Thus, notdir() is
# needed as well.

basename_exes := $(basename $(notdir $(src_exes)))
basename_tests := $(basename $(notdir $(src_tests)))
basename_mods := $(basename $(notdir $(src_mods)))
basename_mods_o := $(addsuffix .o,$(basename_mods))
basenames := $(basename_exes) $(basename_tests) \
             $(basename_mods) $(basename_mods_o)

# All dependency Makefiles (.d files), with directories and extensions.

dep_exes := $(subst $(SRCDIR),$(depbindir),$(src_exes:.$(FEXT)=.d))
dep_tests := $(subst $(SRCDIR),$(depbindir),$(src_tests:.$(FEXT)=.d))

dep_exes_o := $(subst $(depbindir),$(depobjdir),$(dep_exes:.d=.o.d))
dep_tests_o := $(subst $(depbindir),$(depobjdir),$(dep_tests:.d=.o.d))
dep_mods_o := $(subst $(SRCDIR),$(depobjdir),$(src_mods:.$(FEXT)=.o.d))

deps := $(dep_exes) $(dep_exes_o) $(dep_tests) $(dep_tests_o) $(dep_mods_o)

# ENV: FFLAGS  = flags to give to the compiler (e.g -g, -O, -std, -fdec)
#      LDFLAGS = flags to give to the linker (e.g -L, -r)
#      LDLIBS  = library flags to give to the linker (i.e -l...)
#
# These flags are built in such a way that the user can either ADD TO THEM or
# OVERRIDE THEM without editing the Makefile, if that is desired.
#
# - To ADD to them, have the desired variables exported to make.
# - To OVERRIDE them, put them in the make command as the first argument.
#
# Examples:
#
#     - Add to:           $ FFLAGS='-g -O' make exes
#     - Override them:    $ make FFLAGS='-g -O' exes

FFLAGS_ := -Wall -Wextra -Wconversion-extra -pedantic \
           -std=f2018 -fimplicit-none -J$(moddir)

FFLAGS.debug := -g3 -Og -fcheck=all \
                -ffpe-trap=invalid,zero,overflow,underflow,denormal

FFLAGS.release := -O2

FFLAGS := $(FFLAGS_) $(FFLAGS.$(BUILD)) $(FFLAGS)

LDFLAGS_ :=
LDLIBS_ :=

LDFLAGS := $(LDFLAGS_) $(LDFLAGS)
LDLIBS := $(LDLIBS_) $(LDLIBS)

# Final command lines.
#
# These are commands that are used in multiple places. In some cases, it's just
# to be echoed before ran, in muted (@) shells with multiple commands.

compile_cmd = $(FC) $(CFLAGS) $(FFLAGS) -c $< -o $@
link_cmd = $(FC) $(CFLAGS) $(FFLAGS) -o $@ $(LDFLAGS) $^ $(LDLIBS)
copy_cmd = cp -f $< $@
symlink_cmd = ln -sf $< $@
done_cmd = echo -e '$(COLOR_DONE)$(MSG_DONE)$(COLOR_NONE)'
basename_done_cmd = echo '$(copy_cmd)' && $(copy_cmd) && $(done_cmd)
basename_done_cmd_o = echo '$(symlink_cmd)' && $(symlink_cmd) && $(done_cmd)
mkdir_this = $(MKDIR) $(@D)

#####################
###     RULES     ###
#####################

# Main phony rules. First is default ("all").

all:   exes tests
exes:  $(basename_exes)
tests: $(basename_tests)
mods:  $(basename_mods)
deps:  $(deps)

# Static pattern rules for directly making individual programs and modules.
#
# Although fMakefile builds things into the $(BUILDDIR_PREFIX) directory, we
# like to use 'make myprog2' better than 'make build/debug/bin/myprog2'. This is
# what these rules do. By copying the binary into the project root, 'myprog2'
# becomes a real target.
#
# Note: when building a module individually, the .o is copied into project root,
# and a symlink is made to it. That means, basically, that 'make mymod1' does:
#
#     cp build/debug/obj/mod/mymod1.o mymod1.o
#     ln -s mymod1.o mymod
#
# 'make cleancopies' will remove all these from the project root. All (relevant)
# cleaning targets include it though, so you'll rarely need to call it directly.

$(basename_exes)   : % : $(bindir)/%     ; @ $(basename_done_cmd)
$(basename_tests)  : % : $(bintestdir)/% ; @ $(basename_done_cmd)
$(basename_mods)   : % : %.o             ; @ $(basename_done_cmd_o)
$(basename_mods_o) : % : $(objmoddir)/%  ;   $(copy_cmd)

# Pattern rule for linking program binaries.

$(bindir)/% : $(objdir)/%.o
	@ echo -en '$(COLOR_LINK)Linking $*:$(COLOR_NONE) ' && \
	$(mkdir_this) && \
	echo '$(link_cmd)' && $(link_cmd)

# Pattern rule for compiling.
# Applies to all sources (programs and modules).
# When compiling modules, gfortran automatically puts the resulting .mod file
# (byproduct) in the correct directory (specified with -J).

$(objdir)/%.o : $(SRCDIR)/%.$(FEXT)
	@ echo -en '$(COLOR_COMPILE)Compiling $*.$(FEXT):$(COLOR_NONE) ' && \
	$(MKDIR) $(moddir) && \
	$(mkdir_this) && \
	echo '$(compile_cmd)' && $(compile_cmd)

# Pattern rules for the dependency (.d) Makefiles.
#
# Each source file shall have one corresponding .d file. They go in $(depdir)
# ('dep' dir in project root). This recipe runs the source file through our awk
# script to extract the module dependencies from its USE statements.
#
# The awk script is embedded in this Makefile, at the very end of the file.
#
# Details on dependency Makefiles (with examples) in README.md.
#
# We need one target for %.d and another for %.o.d, otherwise "mymod.o.d" would
# look for "src/mod/mymod.o.f90". Unfortunately, both targets in the same rule
# (%.d %.o.d) doesn't work for us, because make has a special interpretation for
# multiple-target rules when they're pattern rules (see GNU make manual "10.5.1
# Introduction to Pattern Rules". So we define two rules, using a template plus
# call-eval to avoid typing the complex recipe twice.

define template_target_dep
$(1) : $(SRCDIR)/%.$(FEXT)
	@ echo 'Updating dependency $$@' && \
	$$(mkdir_this) && \
	echo -n '$$(subst $(DEPDIR)/,$(builddir)/,$$(@:.d=)) :' > $$@ && \
	$(AWK) '$$(call awk_make_dep)' < $$< \
	    | sed -e 'i\ $(objmoddir)/' -e 'a\.o' \
	    | tr -d '\n' \
	    >> $$@ && \
	echo >> $$@
endef
$(eval $(call template_target_dep,$(depbindir)/%.d))
$(eval $(call template_target_dep,$(depobjdir)/%.o.d))

# Cleaning rules.
#
# Cleaning targets are:
#     - clean: entire build dir ($(BUILDDIR_PREFIX)) plus binary copies in
#       project root (see note below).
#     - cleanbuild: individual build dir (build/debug or build/release).
#     - cleanbins: binary directory of current build.
#     - cleanobjs: object directory of current build.
#     - cleandeps: dependency directory ('dep' dir containing .d files).
#     - distclean: everything, that is, 'clean' + 'cleandeps'.
#
# Note: all rules that clean binaries in build dirs also clean the copies in the
# project root (target 'cleancopies') -- except for 'finalclean', which leaves
# only such binaries.

clean_targets := clean cleanbuild cleanbins cleanobjs \
                 cleandeps cleancopies finalclean distclean

clean:      cleancopies ; $(RMDIR) $(BUILDDIR_PREFIX)
cleanbuild: cleancopies ; $(RMDIR) $(builddir)
cleanbins:  cleancopies ; $(RMDIR) $(bindir)
cleanobjs:  cleancopies ; $(RMDIR) $(objdir) $(moddir)
cleandeps:              ; $(RMDIR) $(DEPDIR)

finalclean: cleandeps   ; $(RMDIR) $(BUILDDIR_PREFIX)

distclean: clean cleandeps

cleancopies:
	@ for copy in $(basenames); do \
	    if [ -f $$copy ]; then echo "rm $$copy" && rm $$copy; fi; done

# Target to remove all the comments from this Makefile.

stripmakefile:
	sed 's/^# .*$$\|^#$$//' Makefile | cat -s > Makefile.tmp
	mv -f Makefile.tmp Makefile

.PHONY: all exes tests mods deps $(clean_targets) stripmakefile

# Include all dependency Makefiles (.d files)
#
# As stated above, each source file shall have one corresponding dependency
# file. This 'include' triggers the making of these file (they're targets
# themselves).
#
# The complicated filter function prevents the include when make's goal is not
# about building. That is, when goal is one of: clean*, deps and stripmakefile.
# 'deps' is in that list only because, if it isn't, when 'make deps' is called,
# all deps will already be built when make gets to the deps target, prompting a
# bizarre "Nothing to be done for 'deps'" to show right after building all deps.

include \
    $(if $(MAKECMDGOALS), \
        $(if $(filter-out $(clean_targets) deps stripmakefile,\
            $(MAKECMDGOALS)),$(deps)), $(deps))

####################
###  AWK SCRIPT  ###
####################

# awk script for generating dependency prerequisites.
#
# This is the heart of the Makefile. It scans a source file looking for USE
# statements. Both Fortran's valid forms are considered:
#
#     USE [::] <mod-name>[, only: ...]                     (first block)
#     USE, NON_INTRINSIC :: <mod-name>[, only: ...]        (second block)
#
# "USE, INTRINSIC" is ignored since it's the compiler's job to provide for it.
#
# Upon finding a match, it strips punctuation chars and returns the module name.
#
# (Obvious) limitations of this tool:
#     - This tool needs the USE statement to be in one line up until <mod-name>.
#     - This tool will be fooled by a USE statement that's part of a multi-line
#       string, or such nonsense.

define awk_make_dep
BEGIN {                                          \
    intrinsics["ISO_C_BINDING"];                 \
    intrinsics["ISO_FORTRAN_ENV"];               \
    intrinsics["IEEE_EXCEPTIONS"];               \
    intrinsics["IEEE_ARITHMETIC"];               \
    intrinsics["IEEE_FEATURES"];                 \
};                                               \
                                                 \
toupper($$0) ~ /^\s*USE[: \t]+[A-Z]/ {           \
    gsub(/[,:]/, " ");                           \
    if ( ! (toupper($$2) in intrinsics) ) {      \
        print $$2;                               \
    }                                            \
};                                               \
                                                 \
toupper($$0) ~ /^\s*USE\s*,\s*NON_INTRINSIC/ {   \
    gsub(/[,:]/, " ");                           \
    print $$3;                                   \
}
endef
