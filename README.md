# fMakefile

_Ready-to-use Makefile for simple Fortran projects,
featuring **automatic targets** and **dependency resolution**._

<sub>Copyright (c) 2019-2021 André Chalella</sub> \
<sup>MIT License - see file LICENSE for full text</sup>

## Overview

**fMakefile** is a Makefile for **GNU make** that can be invoked without
modifications and will build your Fortran programs just right, as long as your
project follows a few ground rules. It is intended for simple projects, where
you have a few programs, a few modules and needs everything statically linked.

Suppose your source files live in `proj/src` -- just call **fMakefile** with
`make` from your `proj` directory, and it shall figure everything out
automatically.

Under the hood, **fMakefile** contains (other than **GNU make** makefile code)
**bash** and **awk** scripts that automate everything, all embedded into a
single file for convenience. It generates many tiny makefiles in the `dep/` tree
that represent the dependencies in your project, and builds stuff into the
`build/` tree.

Main features:

## Overview

**fMakefile** needs no modification to work with any simple Fortran project.

As long as your project abides to the rules below), you can just put this
Makefile in your project root and run

    $ make

to compile and link all your programs. You can also run

    $ make myprog

to compile and link a program defined in `src/myprog.f90`. There are many other
possibilites (see the **Examples** section).

**fMakefile** accomplishes the correct prerequisite resolution through static
source code scanning via a small embedded **awk** script. Prerequisites are then
stored in small auxiliary Makefiles in the `dep/` tree, and are read and updated
automatically by **fMakefile** as needed.

Compilation order is then resolved naturally by **make**.  There is no magic,
just plain **GNU make**.

**fMakefile** builds everything into a `build` directory tree, and later copies
binaries into the project root. Upon *clean*ing, all these are done away with.

_For details, read the heavily commented Makefile._

### Features

- Dependency resolution that supports chained dependencies (*program* uses
  *mod1* which uses *mod2* which uses *mod3* -- and everything just works!)
- Automatic targets for fully building each individual source file and more (see
  **Examples**).
- Colorized output for each build step.
- Two sets of build configs (compiler/linker flags): DEBUG and RELEASE.
- Variable `THIS_MAKEFILE` (deferred) provided so any other included Makefile
  can find its own invocation path (note: it must be used before any
  `include` statement).
- Customizable build flags, directory names etc.

### Requirements

- **GNU make**
- **GNU coreutils** (`grep`, `sort`, `uniq`...)
- **bash**

### Rules

1. Each source file must contain one complete program or module.
2. Module names must be the same as their source file names.
3. Directory structure below must be observed.

**fMakefile** required directory structure:

    PROJECT ROOT     MAKEFILE VARIABLE     DESCRIPTION
    ├── Makefile     -                     This file (or its parent)
    ├── src          SRCDIR                Program sources
    │   └── mod      MODDIR_SUFFIX         Module sources
    ├── build        BUILDDIR_PREFIX       Binaries and .mod files
    └── dep          DEPDIR                Dependency Makefiles (.d)

- `build` and `dep` are autogenerated.
- All modules must be in `mod`, without subdirectories.
- Programs may be in subdirectories in `src` (except `mod`).
- All names are customizable (vars above).
- All source files must use the same suffix (extension), by default `.f90`
  (customizable in the `FEXT` variable).

### Examples

Assume the following project tree:

    proj
    ├── Makefile
    └── src
        ├── mod
        │   ├── mod1.f90
        │   └── mod2.f90
        └── program.f90

*Makefile* is **fMakefile** (simplest approach) *or* a Makefile that *includes*
**fMakefile** (recommended approach, since this way you can extend **fMakefile**
without directly modifying it).

Run `make` from the project root:

    $ cd /path/to/proj
    $ make

And an executable named `program` will show up in your project root:

    proj
    ├── build/
    ├── dep/
    ├── src/
    ├── Makefile
    └── program

### Many programs

Assume the following project tree:

    proj
    ├── Makefile
    └── src
        ├── mod
        │   ├── mod1.f90
        │   └── mod2.f90
        ├── test
        │   ├── test1.f90
        │   └── test2.f90
        ├── program1.f90
        └── program2.f90

Running `make` will build **all programs** and put them in your project root:

    $ make

    proj
    ├── build/
    ├── dep/
    ├── src/
    ├── Makefile
    ├── program1
    ├── program2
    ├── test1
    └── test2

**fMakefile** can also build only specific targets:

    $ make program1         # 'program1' is built and copied into project root
    $ make test2            # 'test2' is built and copied into project root
    $ make program1 test1   # 'program1' and 'test1' show up in project root

### Subdirectories

For convenience, you can make all programs in one source subdirectory --
recursively or not. Consider:

    proj
    ├── Makefile
    └── src
        ├── mod
        │   ├── mod1.f90
        │   └── mod2.f90
        ├── program1.f90
        ├── program2.f90
        └── test
            ├── test_sub_1
            │   ├── ts1a.f90
            │   └── ts1b.f90
            ├── test_sub_2
            │   ├── ts2a.f90
            │   └── ts2b.f90
            ├── test1.f90
            └── test2.f90

Then you have some options:

    $ make test/            # all directly under test (test1 and test2)
    $ make test//           # two slashes means RECURSIVE, so this makes:
                            #     test1 test2 ts1a ts1b ts2a ts2b
    $ make test/test_sub_1/ # sure enough, this will make ts1a and ts1b
    $ make test/test_sub_2/ # sure enough, this will make ts2a and ts2b
    $ make .                # the dot is special syntax for 'only source root',
                            # so this will make program1 and program2.

Note: the dot syntax recursive counterpart is, obviously, simply `make` with no
arguments.

### Object files

You can tell **fMakefile** to only compile a specific source file, _be it a
program or a module:_

    $ make program.o        # program.o shows up in your project root
    $ make test1.o
    $ make mod1.o
    $ make mod2.o
    $ make mod/             # compiles and copies all modules

### Making a RELEASE build

By default, **fMakefile** will make a _debug_ build, with debug compiler flags
and into the `build/debug/` tree. To change the build type, just set the `BUILD`
variable:

    $ BUILD=release make            # option 1 (shell variable)
    $ export BUILD=release; make    # option 2 (shell variable)
    $ make BUILD=release            # option 3 (make variable)

Note: you may need to run `make cleancopies` for **fMakefile** to start a
different build type if your project root contains built files from the old
build type, else you may get the `Nothing to be done for '...'` message.

### Cleaning

**fMakefile** has quite a number of phony goals for cleaning:

    $ make clean            # removes all files built and copied into the
                            # project root, plus the build/ dir
    $ make cleancopies      # removes all files copied into the project root
    $ make distclean        # removes EVERYTHING fMakefile has put in your
                            # project root, that is: copies, build/ and dep/
    $ make finalclean       # removes build/ and dep/ (leaves copies)

There's even more, but these are for debugging mostly:

    $ make cleanbuild       # removes build/(debug|release)/ + copies
    $ make cleandeps        # removes dep/

### Ambiguous names

If your source tree has source files with the same name in different
directories, you won't be able to specify the correct one with the basename
syntax (`make program`).

In this case, use this alternative syntax:

    $ make path/to/program          # compile and link src/path/to/program.f90
    $ make path/to/other/program.o  # same name, different subdir, just compile

This way the full path is specified.

Note: when this syntax is used, the result file is not copied to project root
(that is, it stays in the `build/` tree).
