# fMakefile

Ready to use Makefile for simple Fortran projects,
featuring automatic targets and prerequisites

Copyright (c) 2019 André Chalella \
MIT License - see file LICENSE for full text

## Overview

**fMakefile** needs no modification to work with any simple Fortran project.

As long as your project abides to the rules that define "simple" (explained
below), you can just put this Makefile in your project root and run

    $ make

to compile and link all your programs. You can also run

    $ make myprog

to compile and link a program defined in `src/myprog.f90`. There are many other
possibilites, documented below.

**fMakefile** accomplishes the correct prerequisite generation through static
source code scanning (small embedded **awk** script). Prerequisites are then
stored in small auxiliary Makefiles (**.d** files) in a separate tree, and are
read and updated (or recreated) automatically by **make** as needed. Compilation
order is then resolved naturally by **make**.

**fMakefile** builds everything into a *build* directory tree, and later copies
binaries into the project root. Upon *clean*ing, all these are done away with.

For implementation details, read the (heavily commented) Makefile.

### Features:

- Dependency lookup through static source scan, with support for
chained dependencies (*a.mod* uses *b.mod* uses *c.mod*...).
- Automatic targets for fully building each individual source file.
Examples: `make main_prog`, `make mod_calculate`, `make test_fourier_8`
- Phony targets: `make exes` makes all programs, `make tests` makes all tests
(not that tests aren't programs, it's just a way to tell them apart).
- Default target makes all exes and tests (`make` or `make all`).
- Colorized output for each build step.
- Two sets of build configs (compiler/linker flags): DEBUG and RELEASE.
- Variable `THIS_MAKEFILE` (deferred) provided so any other included Makefile
  can find its own invocation path. Warning: it must be used before any
  `include` statement).

### Limitations:

- You must choose one source file extension (variable `FEXT`) and stick
  with it. I chose **.f90**, for instance. This hinders use of automatic
  preprocessing detection in most compilers, however you can turn it
  always on (`-cpp` flag in GFortran).

## Rules

**fMakefile** is made for simple projects, which, in this case, means:

1. Each source file contains one complete program (or module), nothing more.
2. Module names are the same as their source file names.
3. Programs are statically linked with their dependencies (modules).
4. Directory structure as below.

### Directory structure

Here's the default directory structure, with the variables for customization:

    PROJECT ROOT          CUSTOMIZABLE VAR     FULL PATH VARIABLE  AUTOGENERATED?
    ├─ build              BUILDDIR_PREFIX      -                        yes
    │  └─ debug|release   BUILD [env]          builddir                 yes
    │      ├─ mod          see 'src' tree      moddir                   yes
    │      └─ test         see 'src' tree      testdir                  yes
    ├─ dep                DEPDIR               -                        yes
    │  ├─ mod              see 'src' tree      depmoddir                yes
    │  └─ test             see 'src' tree      -                        yes
    └─ src                SRCDIR               srcexedir                 -
       ├─ mod             MODDIR_SUFFIX        srcmoddir                 -
       └─ test            TESTDIR_SUFFIX       srctestdir                -

The structure is customizable, but has some rules itself, which might require
bigger patches if they must be flexibilized:

- **fMakefile** must be run (or included) from the project root
- Program sources go in the source root.
- Module sources go one level below source root. Test program sources too.
- Build tree is standalone, as well as dependencies tree.

The *build* and *dep* trees replicate the *src* tree.

## Targets

Main targets:

    all             default target, makes 'exes' plus 'tests'
    exes            all programs in source root
    tests           all programs in test dir
    clean           cleans everything but the dependency Makefiles
    finalclean      cleans everything but the binaries in project root
    distclean       cleans everything

Misc targets:

    stripmakefile   remove comments from fMakefile (cuts size by half)

Debug targets:

    mods            all modules
    deps            dependency Makefiles (.d files) that go in 'deps' dir
    cleanbuild      removes build directory ($(builddir)) plus copies in project
                    root
    cleancopies     removes binary copies in project root
    cleandeps       removes autogenerated dependency Makefiles (.d files)

### Automatic targets

You can fully build (compile and link) an individual program with:

    $ make program

This will compile and link `src/program.f90` into the build directory tree and
copy the resulting binary to the project root.

The same can be done with a test program:

    $ make test_a

This will make `src/test/test_a.f90`.

You can also *only compile* a program with:

    $ make program.o

This will compile the program into the build tree and, afterwards, copy
`program.o` into your project root.

The same can be done with any other source file.

*Note: when modules are built as goals (i.e not intermediate objects), they're
copied to the project root as **.o files**, and a symbolic link (without the
**.o** suffix) is created pointing to them.*

## Dependency Makefiles (autogenerated .d files)

**fMakefile** dependency generation creates auxiliary Makefiles which merely
state the dependencies themselves.

Each source file has one corresponding auxiliary Makefile (*.d* file) in the
*dep* tree. This file is very simple and consists of one or two lines:

- Line 1: dependencies needed for **compiling**.
- Line 2: dependencies needed for **linking** -- as such, modules won't have
  this line.

An example file `dep/program.d` would be:

    $(builddir)/program.o : $(moddir)/mod1.o
    $(builddir)/program : $(moddir)/mod1.o $(moddir)/mod2.o

In the above example, `program` explicitly USEs `mod1`. This module, in turn,
USEs `mod2`. As such, only `mod1.o` is needed for **compiling** `program`, but,
for **linking**, `mod2.o` is needed as well.

*Note: technically, **mod1.o** is NOT needed for compiling **program.o**; what
IS needed is **mod1.mod** -- which happens to be a byproduct of compiling
**mod1.o**.*

There are other files that exist in the *dep* tree. They are involved in
resolving chain dependencies:

- **.d.d** files: they ensure all the chain dependencies are resolved before
  generating the **.d** file.
- **.use** files: they are the output of the extraction of USE statements (awk
  script).
- **.chain** files: they list all the (chained) dependencies of a module.
