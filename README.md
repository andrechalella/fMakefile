# fMakefile

Ready to use Makefile for simple Fortran projects with
automatic targets and prerequisites (module dependencies)

Copyright (c) 2019 André Chalella \
MIT License - see file LICENSE for full text

## Overview

**fMakefile** needs no modification to work with any simple Fortran project,
"simple" being defined by the rules which are down below. Once it's in your
project root, you can use it straight away with:

    make

which will build all your programs and tests (if any), with correct
compilation order and static linking of needed objects (`USE`d modules). You can
also build an individual program (or test, or module, or any object file) with:

    make <program-name>

See below for full target description.

**fMakefile** accomplishes the correct prerequisite generation through static
source code scanning (small embedded **awk** script). Prerequisites are then
stored in small auxiliary Makefiles (*.d* files) in a separate directory, one
*.d* file per target, and updated (or recreated) automatically as needed, since
they're regular targets too. Compilation order is then resolved naturally by
**make**.

**fMakefiles** builds everything into a *build* directory, and later copies goal
binaries into the project root. Upon *clean*ing, all these are done away with.

For implementation details, read the (heavily commented) Makefile.

## Rules

**fMakefile** is made for simple projects, which, in this case, means:

1. Module source files must contain one complete module, and nothing else.
2. Module names must be the same as their source file names.
3. All module files must be in one directory.
4. Program source files must contain only one complete program, too.
5. All program files must be in one directory (there's a subdirectory for test
   program files).
6. Programs are statically linked to their every dependency object file
   (defined by `USE` statements). Some aren't strictly needed sometimes (e.g.
   modules that contain only types), but it's a very small overhead, and makes
   prerequisite generation much simpler.

If you agree with the default directory structure (below), no customizations are
needed at all.

### Directory structure

Here's the default directory structure, with the variables for customization:

    .                     NAME VARIABLE       FULL PATH VARIABLE  AUTOGENERATED?
    ├── build             $(BUILDDIR_PREFIX)  $(BUILDDIR_PREFIX)       yes
    │   └── debug         $(BUILD) [env]      $(builddir)              yes
    │       ├── bin       $(BINDIR_SUFFIX)    $(bindir)                yes
    │       │   └── test     see src tree     $(bintestdir)            yes
    │       ├── mod          see src tree     $(moddir)                yes
    │       └── obj       $(OBJDIR_SUFFIX)    $(objdir)                yes
    │           ├── mod      see src tree     $(objmoddir)             yes
    │           └── test     see src tree        none                  yes
    ├── dep               $(DEPDIR)           $(DEPDIR)                yes
    │   ├── bin              see build tree   $(depbindir)             yes
    │   │   └── test         see src tree        none                  yes
    │   └── obj              see build tree   $(depobjdir)             yes
    │       ├── mod          see src tree        none                  yes
    │       └── test         see src tree        none                  yes
    └── src               $(SRCDIR)           $(srcexedir)        *    NO    *
        ├── mod           $(MODDIR_SUFFIX)    $(srcmoddir)        *    NO    *
        └── test          $(TESTDIR_SUFFIX)   $(srctestdir)       *    NO    *

The structure is customizable, but has some rules itself, which might require
bigger patches if they must be flexibilized:

- Program sources go in the source root.
- Module sources go one level below source root. Test program sources too.
- Build directory is standalone, as well as dependency Makefiles dir.
- Binaries, objects and *.mod* files dirs go one level below build dir.

Some comments on the structure:

- Object files directory replicates the source directory structure.
- So does the binaries directory, except it doesn't include *mod*.
- Dependency Makefiles directory replicates the build directory structure
  (except for the *.mod* files dir).

## Targets

Main targets:

    all             default target, makes `exes' plus `tests'
    exes            all programs in source root
    tests           all programs in test dir
    clean           cleans everything but the dependency Makefiles
    finalclean      cleans everything but the binaries in project root
    distclean       cleans everything

Misc targets:

    stripmakefile   remove comments from fMakefile (shrinks size to 30%).

Debug targets:

    mods            all modules
    deps            dependency Makefiles (.d files) that go in 'deps' dir
    cleanbuild      removes build directory (build/debug) plus copies in project
                    root
    cleanbins       removes binary directory (build/debug/bin) plus copies in
                    project root
    cleanobjs       removes object directories (build/debug/obj +
                    build/debug/mod) plus copies in root
    cleancopies     removes binary copies in project root
    cleandeps       removes autogenerated dependency Makefiles (.d files)

*Note: when modules are built as goals (i.e not intermediate objects), they're
copied to the project root as **.o files**, and a symbolic link (without the
**.o** suffix) is created pointing to them.*

## Dependency Makefiles (autogenerated .d files)

**fMakefile** dependency generation creates auxiliary Makefiles which merely
state the dependencies themselves.

These auxiliary Makefiles (*.d* files) have one single line, which is nothing
more than a rule with the binary/object as target and its module dependencies as
prerequisites. There's no recipe. This ensures that, in the real
compiling/linking rules, dependencies are fulfilled like below:

- **Compiling:** building dependencies before the target ensures the needed .mod
  files are in the .mod directory (gfortran -J option). They don't need to be
specified individually in the compile command.

- **Linking:** when dependencies are specified as prerequisites, they make their
  way into the link command via the $^ automatic variable.

The *.* files are generated via an embedded **awk** script (plus some shell
manipulation).

Example dependency Makefiles:

- Example binary:
  - Source: `src/myprog.f90`
  - Uses: `mymod1`, `mymod2`, `mymod3`
  - Target: `build/debug/bin/myprog`
  - Contents of `dep/bin/myprog.d`:

        build/debug/bin/myprog : build/debug/obj/mod/mymod1.o [ continues ]
            build/debug/obj/mod/mymod2.o build/debug/obj/mod/mymod3.o

- Example object:
  - Source: *same as above*
  - Uses: *same as above*
  - Target: `build/debug/obj/myprog.o`
  - Contents of `dep/obj/myprog.o.d`:

        build/debug/obj/myprog.o : build/debug/obj/mod/mymod1.o [ continues ]
            build/debug/obj/mod/mymod2.o build/debug/obj/mod/mymod3.o

- Example module:
  - Source: `src/mod/mymod1.f90`
  - Uses: `mymod9`
  - Target: `build/debug/obj/mod/mymod1.o`
  - Contents of `dep/obj/mod/mymod1.o.d`:

        build/debug/obj/mod/mymod1.o : build/debug/obj/mod/mymod9.o
